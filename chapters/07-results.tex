%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Analysis and Discussion}\label{ch:analysis}

In this chapter, a critical analysis of the algorithms is presented, as well as an overview of how useful are the results and what are their shortcomings.
The results from chapters~\ref{ch:interval} and~\ref{ch:querypart} show that simple approaches can be used to enhance the query response time for the selected queries, and can be easily ported to other domains and styles of computation.

\autoref{tab:analysis_overview} shows the characteristics in which each algorithm has showed to excel at.
FragCubing is still preferred when the data has a low degree of sequentiality, as there's little advantage in using the IntervalFrag scheme when the intervals are closer to the size of the original list.
On those cases, IntervalFrag is discouraged, as the algorithm will be slower than FragCubing's by simple virtue of needing more instructions to answer the same query, being up to 400\% slower than the same query under FragCubing.

When the dimensions have a high degree of sequentiality, then IntervalFrag excels, as it can not only answer the same queries much faster, but also using only a fraction of the memory used by FragCubing.
Furthermore, FragCubing used much less memory to answer queries $Q1$, $Q2$ and $Q5$, with $Q4$ having a small difference and $Q3$ having no difference in memory usage in the end.
All queries executed on the $C0$ cube with all dimensions used only a \textcolor{red}{HOW MUCH?} fraction of the memory needed to answer queries with IntervalFrag, they were however in general much slower to answer.

\begin{table}[!ht]
  \begin{center}
    \caption{Preferred algorithm to use}\label{tab:analysis_overview}
    \footnotesize
    \begin{tabular}{|C{2.5cm}|C{2.3cm}|C{2.3cm}|C{2.8cm}|C{2cm}|C{1cm}|}
      \hline
      & \bfseries Low Sequentiality &\bfseries High Sequentiality &\bfseries High Dimensionality &\bfseries High Cardinality &\bfseries High Skew \\
      \hline
      Computing the base cube & & & & & \\
      \hline
      Subcube query& & & & & \\
      \hline
      Low available RAM& & & & & \\
      \hline
      High data dimensionality& & & & & \\
      \hline
    \end{tabular}
  \end{center}
\end{table}
\normalsize

- A paragraph just dealing with the differences between the algos

- At least a new graph just to compare the results

- How about that big table here? Or on the other chapter?

From the tests made using FragCubing and the different cubes ($C1$ to $C5$) tailored to specific queries, it was shown that the best algorithms can be further enhanced by doing some simple pre-processing of the queries, and depending on the type of query used they can drastically improve upon memory usage requirements, allowing for some frequent queries to be optimized and even allowing for queries that could not be answered under a $C0$ cube to be answered by smaller cubes.
In chapter~\ref{ch:querypart} it was shown that it is faster to load a smaller subset of the data in memory as prepared files when needed and then computing the answer from that file instead of querying a cube that was already loaded in memory, but that used the full dimensional capability of the data.

It is important to note IntervalFrag had faster file reading speeds due to improvements made on the implementation, as well as a slightly more efficient set intersection algorithm, which were not backported to FragCubing.
This was done to preserve the FragCubing algorithm's performance, as the original code was made for the C language in 2002 and the updated IntervalFrag implementation uses modern C++ standards.
Nonetheless, it was possible to compile FragCubing using the same flags as IntervalFrag under the GNU C++ compiler, with minimal performance differences.

The difference in query response times from IntervalFrag and FragCubing, even when using the same intersection algorithm, was due to IntervalFrag having to do more comparisons to answer the same query, and this implementation could not be further optimized without heavily skewing the response times to IntervalFrag's side.
Further details on the intersection algorithms tested and their performance differences can be found on Appendix~\ref{ap:a:problem}.

